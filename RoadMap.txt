                                    ROADMAP :

OBJECTIF : 

-afficher une invite de cmd

-conserver un historique de cmd

-rechercher et lancer un fichier executable en fonction du PATH
ls equivaut a /bin/ls etc

-utiliser au maximum une variable globale afin d'indiquer la
reception dun signal / cette variable doit seulement stocker le numero
du signal et ne doit fournir aucune information ni acces au donnee

-ne pas considirer les guillemet non fermer ni les char speciaux nn requis 
par le sujet tel que \ ou ;

-gerer l'apostrophe afin dempecher le terminal dinterpreter les metachractere
dans la sequence entre guillemet

-pour la double apostrophe meme chose que le precedent sauf le signe dollar $

// REDIRECTION //
-implementer les redirection > : redirige la sortie et < : redirige lentree

// HEREDOC //
-gerer les << recoit un delimiteur puis lit jusqua le rencontrer avec
historique non mis a jour 

-gerer les >> : redirige la sortie en mode ajout

// PIPE //
-implementer les pipe

// ENV //
-gerer les variable denvironnement $ suivi dune sequence de char
-gerer $? qui doit etre remplacer par le code de sortie du dernier pipeline

-gerer le comportement ctrl+D ctrl+C ctrl+\ qui doivent se comporter
comme dans bash

-en mode interactive ctrl+C affiche une nouvelle invite sur une new ligne
-ctrl+D quitte linterpreteur de cmd
-ctrl+\ ne fais rien 

-implementer les commande :
-->"echo" avec loption "-n" : option n empeche le retour a la ligne a la fin 
-->"cd" avec un chemin relatif ou absolue
-->"pwd" affiche le chemin
-->"export" exporte des variable d'env em tant que processus enfant sans affecter
celle existante
-->"unset" permet de supprimer une variable
-->"env" affiche lenvironnement actuel ou exec un cmd specifique dans un
env modifier
-->"exit" quitte une session de terminal

- IMPORTANT : pas obliger de corriger les fuite de memoire de la fonction READLINE
mais on va quand meme le faire ;)

BONUS :

-implementer les && et les || avec les parenthese pour la prioriter
-le caractere "*" doit fonctionner pour le travail de repertoire courant

DEF :

1. metacaractere : type de caractere informatique exemple : ? * %
2. READLINE() : lit une ligne depuis le terminal et la renvoie
3. rl_clear_history() : efface la liste dhistorique en supprimant tt les entree.
4. rl_on_new_line() : indique a la routine de maj que nous somme passer a une new ligne vide
5. rl_replace_line() : ??????
6. rl_redisplay() : modifier ce quil ya a lecran
7. add_history() enrigistre une ligne passer en parametre dans lhistorique afin de la recup plus tard dans le terminal
8. printf()
9. malloc()
10. free()
11. write()
12. acces() : verifie si le processus peut acceder au fichier pathname
13. open()
14. read()
15. close()
16. fork() : cree un processus (enfant) identique au processus de base (parent)
    /cest une copie dun processus
    /exemple : jai un processus (parent) j'appele fork() et pouf jai un clone (processus enfant)
    les 2 ont exactement le meme code et les meme variable en memoire au moment du clonage donc
    apres fork il ya 2 processus.
    /fork retourne une valeur differente dans chaque processus 
    le parent return le PID de lenfant ">0" et lenfant return "0"

17. wait() : attend qu'un des processus (enfant) fini
18. waitpid() : le parent se met en pause jusqua ce que le fils preciser se finit
19. wait3() : obsolete aujourdhui
20. wait4() : meme chose que waitpid mais avec des information detailler supplementaire
21. signal() : msg emit a destination dun processus
22. sigaction() : examine et modifie laction assocer a signal()
23. sigemptyset() : vide lensemble des signaux fourni par le parametre set
24. sigaddset() : ajoute le signal "signum" dans lensemble "set"
25. kill() : utiliser pour envoyer nimporte quel signal a nimporte quel processus
26. exit()

getcwd : Permet de retourner le chemin absolu d un repertoire, buffer est la chaine qui va etre renvoye pour donner le nom, les erreurs indiquent taille de buffer pas assez grande ou pas acces au dossier
chdir : Permet de changer de repertoire, le nouveau chemin passe en parametre return 0 si accessible -1 sinon erno gere les erreurs
stat lstat fstat : toutes les trois identiques elles renvoient des informations sur le fichier en parametre, difference : stat et lstat doivent avoir la permission d execution pour tous les repertoires de path qui menent au fichier fstat meme chose que stat mais le fichier ouvert est pointe par le fd, lstat si lien symbolique, donne les stats du lien
unlink : detruit un nom de fichier et le ficiher associe
excve : permet d executer un programme, il execute seulement les fichiers binaire
dup et dup2 : permet de duppliquer des fd
pipe : cree un "tube" permettant de faire le lien de communication entre 2 processus
opendir : ouvre un repertoire, renvoie un pointeur sur le flux ouvert
readdir : permet de voir l etat du repertoire envoye en parametre 
close dir : permet de fermer le flux d un repertoire ouvert
streror et perror : permet d avoir l erreur d afficher sterror affiche le code derreur perror affiche l erreur et on peut afficher un message personnalise
isatty : savoir si le fd est un termninal 
ttyname : renvoie le nom du terminal
ttyslot : permet  d avoir l emplacement terminal en cours dans un fichier valeur de retour d erreur 0 sur unix v6 v7 et BSD -1 sur les systeme V 
ioctl : permet de forcer des operations sur les peripheriques en faisant des appels systemes, un code est envoye en parametre et un fd pour preciser sur quel peripherique on veut forcer quelle commande
getenv : permet de recuperer le contenu d une variable d environnement
tcsetattr tcgetattr : permet de recuperer et modifier les ports de communications asynchrone 
tgetent, tgetflag, tgetnum, tgetstr, tgoto, tputs : Permet de gerer le terminal 
    tgetent : permet de verifier que le base de donnes est fonctionnelle et utilisable 
    tgetflag : marhce comme tgetnum juste renvoie un booleen permettant de savoir si lorsque l on va executer tel ou tel commande le terminal en est capable selon ses capacites
    tgetnum : permet de recuperer le nombre de lignes et de colonnes du terminal par exemple il faut avoir le bon id pour recuperer l info numerique que lon veut
    tgetstr : permet de recuperer les termcaps (par  exemple cl pour colonne) pour les utiliser
    tputs : permet d executer le tgestr recuperer
    tgoto : permet d avoir les capacites max des parametres col et lignes selon la commande a executer

    Termcap 	Terminfo 	Description
co 	cols 	nombre de colonnes affichées à l’écran
li 	lines 	nombre de lignes affichées à l’écran
AF 	setaf 	définit la couleur du texte
AB 	setab 	définit la couleur de fond
md 	bold 	affiche le texte en « gras »
us 	smul 	affiche le texte en « souligné »
mb 	blink 	affiche le texte en « clignotant »
cm 	cup 	déplace le curseur aux coordonnées souhaitées
cl 	clear 	efface le texte affiché à l’écran
me 	sgr0 	annule tous les changements opérés
os 	os 	over strike, précise si le terminal efface ou non le contenu lors d’une réécriture par dessus du texte (par exemple à la suite d’un backspace)

====================================================================================================================================================================================================================


1. Un arbre c'est quoi ? 

c'est une structure de donnee avec des noeud reliee entre eux de maniere hierarchique

exemple :
        [A]          racine
       /   \
     [B]   [C]       enfant de A
     / \     \
   [D] [E]   [F]     feuille 

racine  : tjrs le noeud tout en haut
branche : les noeud qui ont des enfant donc A B C 
feuille : les noeud tt en bas qui n'ont pas d'enfant 


bon voici un exemple plus concret de ce que jai compris imagine que tu as une expression mathematique que voici : 

5 + 2 * 4

comment lire de gauche ou de droite eh bien il ya une prioriter en math on va lire :

2 * 4 = 8
5 + 8 = 13

si on represente ca en arbre ca donne ca :

        [+]               racine --> donc operation final
       /   \
     [5]   [*]            enfant de + --> gauche : 5 et droite : une sous expression 2 * 4
           /  \
         [2]  [4]         feuille --> on resou dabord les feuille ensuite on remonte

conclusion l'arbre va auutomatiquement respecter lordre des operation


/--------------------------------------------------------------\


2 . Mnt cest quoi AST (ABSTRACT SYNTAX TREE) ?

c'est une representation simplifier et structrer

TREE     --> ce quon a vu precedement est ce quon appelle : 
SYNTAX   --> l'arbre represente la syntax dune expression donc les regle de grammaire
             pour 5 + 2 * 4 :
             la syntax nous dit multiplication prioritaire sur addition
ABSTRACT --> on abstrait les detail inutile
             pour 5 + 2 * 4 :
             on garde les nombre et operation et on enleve les espace parenthese etc


donc en conclusion un ast cest une structure en arbre facile a parcourir recursivement et abstrait
les operation prioritaire sont plus bas et ceux avec faible prioriter sont plus haut

en C donc ce qui nous interesse ca donne ca :

typedef struct s_tree_node
{
    void    *data; // donne du noeud
    struct s_tree_node  *left; // enfant gauche
    struct s_tree_node  *right; // enfant droit
} t_tree_node;


/-------------------------------------------------------------\


3. On va appliquer cette theorie a minishell hahahahahahhahaha

dans minishell nos operation ca va etre :

pipe        :  |
redirection :  <, >, <<, >>

et pour les bonus quon va bien evidement faire en LEGENDE (ps : je suis sous big music epic je suis hype hahaha):

||, &&

donc si on fais --> ls -la

  [CMD]
    |
  ["ls", "-la", NULL]       feuille

et si on fait    --> ls | grep test 
en math ca donne :   ' ls PIPE grep ' donc :

      [PIPE]           racine  --> notre operation final
      /    \
   [CMD]  [CMD]        feuille
     |      |
   ["ls"] ["grep", "test"]

on va connecter stdout de ls vers stdin de grep ce qui est je rappelle le principe d'une pipe : un tuyaux de connexion 

mnt si on fais uun big test : cat < input | grep test

           [PIPE]              racine  --> la pipe est tjrs la prioriter la plus faible donc racine
          /      \
    [REDIR <]   [CMD]          branche --> a gauche : cat < input ya une redirection et droite : grep test donc cmd simple
        |         |
      [CMD]   ["grep", "test"]
        |
   ["cat", NULL]

donc si on execute on va :

cree la pipe 
fork a gauche donc : ouvrir input (notre redirection) , execter cat , connecter stdout a la pipe 
fork a droite donc : excuter grep test , connecter stdin a la pipe 


/-------------------------------------------------------------\


donc dcp on va cree nos structure de donnee a lavance puis decouper notre ligne de cmd je crois que c ca la tokenisation
on va ensuite faire le parsing de nos token dcp construire notre ast 
ensuite on va exec tout ca en parcourant notre ast de bas en haut 


/-------------------------------------------------------------\


4. Les redirection

< : redirection dentree input // lit depuis stdin mais pointe vers fichier.txt au lieu d clavier
exemple : cat < fichier.txt

int fd = open("fichier.txt", O_RDONLY);
dup2(fd, STDIN_FILENO);
close(fd);
execve("/bin/cat", args, envp);
==============================================================

> : redirection de sortie output // ecrit sur stdout mais pointe vers fichier.txt au lieu de l'ecran
exemple : ls > fichier.txt

int fd = open("fichier.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
dup2(fd, STDOUT_FILENO);
close(fd);
execve("/bin/ls", args, envp);
===============================================================

>> : redirection en mode ajout append
exemple :
echo "ligne 1" > fichier.txt   // ecrase le fichier
echo "ligne 2" >> fichier.txt  // ajoute Ã  la fin

int fd = open("fichier.txt", O_WRONLY | O_CREAT | O_APPEND, 0644);
dup2(fd, STDOUT_FILENO);
close(fd);
execve("/bin/echo", args, envp);

<< : heredoc // lit depuuis ce que tu va ecrire depuis le terminal avec comme arret le delimiteur


/-------------------------------------------------------------------\


5. Les quote

les quote simple : tout les metacharactere sont ignorer

les quote double : tout les metacharactere sont ignorer hormis $
exemple : echo "hello $USER" va etre remplacer par luusername 
les expansion de variable sont interpreter

si les quote sont coller alors on a un seul token

si les quote sont vide alors le token aussi est vide 